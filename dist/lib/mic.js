import{LorawanVersion as h}from"./LoraPacket.js";import{reverseBuffer as s}from"./util.js";import{AesCmac as M}from"aes-cmac";import{Buffer as t}from"buffer";function g(e,i,r,E,n){let w=h.V1_0;if(e.isJoinRequestMessage()){if(r&&r.length!==16)throw new Error("Expected a AppKey with length 16");if(!e.MHDR)throw new Error("Expected MHDR to be defined");if(!e.AppEUI)throw new Error("Expected AppEUI to be defined");if(!e.DevEUI)throw new Error("Expected DevEUI to be defined");if(!e.DevNonce)throw new Error("Expected DevNonce to be defined");if(!e.MACPayload)throw new Error("Expected DevNonce to be defined");const f=t.concat([e.MHDR,e.MACPayload]);let c=new M(r).calculate(f);return c instanceof t||(c=t.from(c)),c.slice(0,4)}else if(e.isReJoinRequestMessage()){if(e.RejoinType[0]===1&&(!r||r.length!==16))throw new Error("Expected a JSIntKey with length 16");if((e.RejoinType[0]===0||e.RejoinType[0]===2)&&(!i||i.length!==16))throw new Error("Expected a SNwkSIntKey with length 16");if(r&&r.length!==16)throw new Error("Expected a AppKey with length 16");if(!e.MHDR)throw new Error("Expected MHDR to be defined");if(!e.RejoinType)throw new Error("Expected RejoinType to be defined");if(!e.NetID&&!e.AppEUI)throw new Error("Expected NetID or JoinEUI to be defined");if(!e.DevEUI)throw new Error("Expected DevEUI to be defined");if(!e.RJCount0&&!e.RJCount1)throw new Error("Expected RJCount0 or RJCount1 to be defined");const f=t.concat([e.MHDR,e.MACPayload]),c=e.RejoinType[0]===1?r:i;let o=new M(c).calculate(f);return o instanceof t||(o=t.from(o)),o.slice(0,4)}else if(e.isJoinAcceptMessage()){if(r&&r.length!==16)throw new Error("Expected a AppKey with length 16");if(!e.MHDR)throw new Error("Expected MHDR to be defined");if(!e.AppNonce)throw new Error("Expected AppNonce to be defined");if(!e.NetID)throw new Error("Expected NetID to be defined");if(!e.DevAddr)throw new Error("Expected DevAddr to be defined");if(!e.DLSettings)throw new Error("Expected DLSettings to be defined");if(!e.RxDelay)throw new Error("Expected RxDelay to be defined");if(!e.CFList)throw new Error("Expected CFList to be defined");if(!e.MACPayload)throw new Error("Expected MACPayload to be defined");e.getDLSettingsOptNeg()&&(w=h.V1_1);let f=t.alloc(0),c=r;if(w===h.V1_0)f=t.concat([e.MHDR,e.MACPayload]);else if(w===h.V1_1){if(!e.JoinReqType)throw new Error("Expected JoinReqType to be defined");if(!e.JoinEUI)throw new Error("Expected JoinEUI to be defined");if(!e.DevNonce)throw new Error("Expected DevNonce to be defined");if(!i||i.length!==16)throw new Error("Expected a NwkSKey with length 16");c=i,f=t.concat([e.JoinReqType,s(e.JoinEUI),s(e.DevNonce),e.MHDR,e.MACPayload])}let o=new M(c).calculate(f);return o instanceof t||(o=t.from(o)),o.slice(0,4)}else{if(i&&i.length!==16)throw new Error("Expected a NwkSKey with length 16");if(e.DevAddr&&e.DevAddr.length!==4)throw new Error("Expected a payload DevAddr with length 4");if(e.FCnt&&e.FCnt.length!==2)throw new Error("Expected a payload FCnt with length 2");if(!e.MHDR)throw new Error("Expected MHDR to be defined");if(!e.DevAddr)throw new Error("Expected DevAddr to be defined");if(!e.FCnt)throw new Error("Expected FCnt to be defined");if(!e.MACPayload)throw new Error("Expected MACPayload to be defined");if(E||(E=t.from("0000","hex")),n){if(!r||r?.length!==16)throw new Error("Expected a FNwkSIntKey with length 16");w=h.V1_1}let f;const c=e.getDir()==="up"&&w===h.V1_1,o=e.getDir()==="down"&&w===h.V1_1;if(e.getDir()=="up")f=t.alloc(1,0);else if(e.getDir()=="down")if(f=t.alloc(1,1),!n)n=t.alloc(4,0);else{if(n&&n?.length!==2)throw new Error("Expected a ConfFCntDown with length 2");n=t.concat([n,t.alloc(2,0)])}else throw new Error("expecting direction to be either 'up' or 'down'");if(c){if(!n||n?.length!==4)throw new Error("Expected a ConfFCntDownTxDrTxCh with length 4 Expected ( ConfFCnt | TxDr | TxCh)");e.getFCtrlACK()||c&&e.getFPort()===0?n.writeUInt16BE(n.readUInt16LE(0)):n.writeUInt16BE(0)}const d=e.MHDR.length+e.MACPayload.length,D=t.concat([t.from([73]),o?n:t.alloc(4,0),f,s(e.DevAddr),s(e.FCnt),E,t.alloc(1,0),t.alloc(1,d)]),m=t.concat([D,e.MHDR,e.MACPayload]);let I=i;o&&(I=r);let u=new M(I).calculate(m);u instanceof t||(u=t.from(u));const R=u.slice(0,4);if(c){const b=t.concat([t.from([73]),n,f,s(e.DevAddr),s(e.FCnt),E,t.alloc(1,0),t.alloc(1,d)]),P=t.concat([b,e.MHDR,e.MACPayload]);let l=new M(r).calculate(P);l instanceof t||(l=t.from(l));const x=l.slice(0,4);return t.concat([x.slice(0,2),R.slice(0,2)])}return R}}function A(e,i,r,E,n){if(e.MIC&&e.MIC.length!==4)throw new Error("Expected a payload payload.MIC with length 4");const w=g(e,i,r,E,n);return e.MIC?t.compare(e.MIC,w)===0:!1}function C(e,i,r,E,n){const w=g(e,i,r,E,n);if(e.MIC=w,!e.MHDR)throw new Error("Missing MHDR");if(!e.MACPayload)throw new Error("Missing MACPayload");if(!e.MIC)throw new Error("Missing MIC");if(!e.MHDR)throw new Error("Missing MHDR");e.PHYPayload=t.concat([e.MHDR,e.MACPayload,e.MIC]),e.MACPayloadWithMIC=e.PHYPayload.slice(e.MHDR.length,e.PHYPayload.length)}export{g as calculateMIC,C as recalculateMIC,A as verifyMIC};
